\documentclass{article}

\usepackage[norsk]{babel}
\usepackage{chicago}
\usepackage[T1]{fontenc}
\usepackage{footnote}
\usepackage[dvips]{hyperref}
\usepackage{multirow}
\usepackage{verbatim}

\newcommand\note[1]{\marginpar{\raggedright\tiny#1}}
\newcommand\link[1]{\href{#1}{#1}}

\let\code\texttt
\let\form\emph
\let\lib\emph
\let\prog\texttt
\let\w\emph

\title{Toniv\aa{}morfologi for latin\footnote{Denne rapporten er ogs\aa{}
tilgjengelig som PDF fra \link{http://heim.ifi.uio.no/arnskj/TODO}}}
%\author{Kandidat 6472}
%\author{Arne Skj\ae{}rholt}
\date{} % XXX: Ja of nee?

\begin{document}
\maketitle

\section{Introduksjon}
%\subsection{Historisk bakgrunn}
\note{Litt mykere start. ``Denne oppgaven presenterer\ldots''}
Tradisjonelle generative modeller for morfologi ble skrevet som
kontekst-sensitive omskrivningsregler p\aa{} m\o{}nsteret $\alpha \to
\beta/\gamma \_ \delta$: $\alpha$ omskrives til $\beta$ mellom $\gamma$ og
$\delta$, der $\alpha$, $\beta$, $\gamma$ og $\delta$ er vilk\aa{}rlig
kompliserte strenger. I det generelle tilfellet er slike regler et meget
vanskelig problem \aa{} l\o{}se\footnote{Problemet er det som kalles
PSPACE-komplett. Dette inneb\ae{}rer antageligvis at tiden det tar \aa{}
l\o{}se problemet tar tid som \o{}ker eksponensielt med st\o{}rrelsen p\aa{}
grammatikken. Hvorvidt dette faktisk er tilfelle er et av de store ul\o{}ste
problemene i teoretisk informatikk, men den gjengse oppfatning er at dette er
tilfelle.}, men det viser seg at man i generativ morfologi antar at man
beveger seg videre i strengen etter at en omskrivning er utf\o{}rt. Dette
inneb\ae{}rer at n\aa{}r $\gamma\alpha\delta$ er omskrevet til
$\gamma\beta\delta$ forblir $\beta$-delen uendret, og man fortsetter \aa{}
omskrive til h\o{}yre eller venstre for $\beta$. Dette endrer kompleksiteten
p\aa{} problemet radikalt, og dette problemet viser seg \aa{} kunne l\o{}ses
med endelige tilstandsmaskiner\footnote{Et problem som kan l\o{}ses i
polynomisk tid.}. Dette arbeidet begynte p\aa{} 60-tallet og kuliminerte i
Kimmo Koskenniemis toniv\aa{}formalisme i 1983, som fort ble det gjeldende
paradigmet i feltet. \cite{twolc}

%\subsection{Form\aa{}l}
Selv om problemet viser seg \aa{} v\ae{}re beregningsmessing forholdsvis lett
\aa{} h\aa{}ndtere, er det \aa{} implementere en komplett toniv\aa{}modell
ikke en triviell oppgave. Det er blant annet skrevet hovedfagsoppgaver der
m\aa{}let er nettopp dette, se \citeN{bondihoved} og \citeN{french}. M\aa{}let
for dette prosjektet har derfor v\ae{}rt \aa{} implementere en delmengde av
det latinske formverket som er s\aa{} interessant som mulig; der interessant
er definert slik at s\aa{} mange implementasjonstekniske problemer som mulig
blir eksponert. Uregelmessige former, selv om de kanskje rent praktisk sett er
veldig interessante, er for eksempel ikke s\ae{}rlig inspirerende i denne
sammenhengen ettersom implementasjonen stort sett kan oppsummeres som ``for
denne roten ser denne formen slik ut''.

%\subsection{Planen}
Den planlagte fremgangsm\aa{}ten, som stort sett korresponderer med den
faktiske gangen i arbeidet med implementasjonen, var \aa{} begynne i det
sm\aa{} med regelrette substantiver for \aa{} bli kjent med verkt\o{}yene og
gi grunnleggende f\o{}ringer p\aa{} hvordan de kan integreres med standard
UNIX-verkt\o{}y som \prog{make} for \aa{} automatisere kompilasjonsprosessen.
Etter dette sto verbalsystemet for tur. Siden verbalparadigmet er den mest
kompliserte delen av den latinske morfologien ans\aa{} jeg det som viktig
\aa{} utforske denne delen av systemet for \aa{} finne ut hvor kompliserte
regler som trengtes. Etter dette var planen \aa{} implementere det som gjensto
av de regelrette verbal-- og substantivparadigmene.

%\subsection{Funksjonalitet}\note{Dette m\aa{} skrives.}
I sin n\aa{}v\ae{}rende form analyserer og genererer systemet verb--,
substantiv-- og adjektivformer for leksikonet gitt i tabell \ref{leksikon}.
For substantiv skal applikasjonen ha full dekning for regelrette ord i
f\o{}rste, andre, fjerde og femte deklinasjon. I den tredje deklinasjonen
mangler paradigmene p\aa{} \w{--ium} i genitiv flertall. Systemet skal
ogs\aa{} klare regelrette adjektiver i alle kj\o{}nn og grader, samt deres
avledede adverber. I verbalparadigmet skal det ogs\aa{} v\ae{}re full dekning
for regelrette verb, b\aa{}de vanlige og deponente verb, etter alle de fire
konjugasjonene, inklusive i-stammeverbene i tredje konjugasjon (eksklusive
perifrastiske former).

\begin{table}
\begin{center}
\begin{tabular}{|ccc|}
    \hline
Substantiv  & Adjektiv    & Verb \\
    \hline
\w{rosa}    & \w{longus}  & \w{amo}     \\
\w{dominus} & \w{pulcher} & \w{hortor}  \\
\w{numerus} & \w{acer}    & \w{moneo}   \\
\w{filius}  & \w{brevis}  & \w{vereor}  \\
\w{puer}    & \w{felix}   & \w{rego}    \\
\w{ager}    &             & \w{sequor}  \\
\w{bellum}  &             & \w{capio}   \\
\w{rex}     &             & \w{patior}  \\
\w{corpus}  &             & \w{audio}   \\
\w{fructus} &             & \w{partior} \\
\w{cornus}  &             &             \\
\w{res}     &             &             \\
    \hline
\end{tabular}
\end{center}
\caption{Leksikon}
\label{leksikon}
\end{table}

Vi skal n\aa{} f\o{}rst se p\aa{} hvilken programvare systemet er avhengig av,
hva slags modell som ligger til grunn for implementasjonen, og hvordan selve
implementasjonen er utf\o{}rt. Til slutt skal vi s\aa{} hvordan systemet
passer inn i en mer teoretisk lingvistisk kontekst.

\section{Implementasjonen}
%\subsection{N\o{}dvendig programvare}
For \aa{} kompilere selve morfologidelen av applikasjonen trengs bare
Xerox-verkt\o{}y\-kassen for endelig tilstandsmorfologi (XFST), og en
implementasjon av \prog{make} for \aa{} bygge applikasjonen (applikasjonen kan
ogs\aa{} bygges manuelt). I tillegg trenger testsuiten Python-grensesnittet mot
XFST\footnote{\href{http://www.stanford.edu/~laurik/.book2software/download.html}
{http://www.stanford.edu/\~{}laurik/.book2software/download.html}}, biblioteket
\lib{PyTAP}\footnote{\link{http://git.codesimply.com/?p=PyTAP.git;a=summary}}
og applikasjonen \prog{prove} fra Perl-biblioteket
\lib{Test::Harness}\footnote{\href{http://search.cpan.org/~andya/Test-Harness/}
{http://search.cpan.org/\~{}andya/Test-Harness/}},
versjon 3 eller h\o{}yere. Hvis FIXMEFIXMEFIXME
(installeres sammen med de fleste moderne versjoner av Perl\note{Sjekke at
dette stemmer.}).
Webgrensesnittet\footnote{\link{http://heim.ifi.uio.no/arnskj/cgi-bin/latin/analyse.cgi}}
krever bare Python-grensesnittet mot XFST.

XFST gir tre alternativer for \aa{} skrive endelige tilstandsautomater:
\prog{xfst}, \prog{lexc} og \prog{twolc}. \prog{xfst} er et generelt
verkt\o{}y for \aa{} skrive automater, og fungerer generelt p\aa{} et for lavt
niv\aa{} for dette prosjektet og brukes bare for \aa{} regularisere
dataformatet fra adverbavledningen (seksjon \ref{deklinasjon}). \prog{lexc} er
et verkt\o{}y for \aa{} skrive leksikon, og spesifiserer regul\ae{}re
relasjoner som h\o{}yrerekursive grammatikker. Hoveddelen av applikasjonen er
implementert i \prog{lexc}. \prog{twolc} spesifiserer relasjoner i form av
kontekstsensitive regler, men som nevnt over er uttrykkskraften likevel
begrenset til regul\ae{}re relasjoner p\aa{} grunn av antagelsen om at bare
\'en regel kan benyttes p\aa{} et vilk\aa{}rlig punkt i inputstrengen.
\cite{xfst,twolc}

Automatene som XFST genererer har den nyttige egenskapen at de kan kj\o{}res i
begge retninger, det vil si at en automat som analyserer morfologi ogs\aa{}
kan generere former fra en analyse, og en generator kan analysere former. Jeg
har benyttet meg av denne egenskapen, og koden som er skrevet spesifiserer en
\emph{generator} for latinsk morfologi, ikke en analysator. Men siden
resultatet er en automat som g\aa{}r i begge retninger fungerer den like godt
som analysator. Dette har lettet implementasjonen betraktelig av to grunner:
For det f\o{}rste er alle beskrivelser av morfologien strukturert som
beskrivelser av hvordan en overflateform dannes fra en analyse; for det andre
er det kognitivt lettere for meg \aa{} ta for meg en b\o{}yningsklasse og
hvilke endelser de forskjellige formene tar enn \aa{} enumerere alle mulige
analyser for en gitt endelse. I all hovedsak har jeg tatt utgangspunkt i
\citeN{eitrem} sin beskrivelse av morfologien (\S\S 8--24 for substantiv og
adjektiv, \S\S 36--41 for verbene). I tillegg var \citeN{ernout} oppklarende i
enkelte detaljer omkring sammentrukne former p\aa{} \w{--vi} i
perfektumssystemet (pp.~209--212).

Webgrensesnittet er et helt grunnleggende grensesnitt mot applikasjonens
fundamentale funksjoner, analyse og generering av latinsk morfologi,
implementert som et CGI-script i Python. Testene er ogs\aa{} skrevet i Python,
men genererer testdata i et format vanligvis brukt for \aa{} teste Perl-kode
(TAP). Jeg har valgt \aa{} gj\o{}re det p\aa{} denne m\aa{}ten ettersom TAP
har en sv\ae{}rt lav terskel for bruk, noe som har gjort at testene kan
implementeres med et minimum av arbeid.

Webgrensesnittet\footnote{\link{http://heim.ifi.uio.no/arnskj/cgi-bin/latin/analyse.cgi}}
har et ganske rudiment\ae{}rt brukergrensesnitt som burde v\ae{}re
selvforklarende: En b\o{}yd form skrives inn i tekstfeltet og man klikker
p\aa{} ``Analyser'' for \aa{} f\aa{} en liste over analyser, eller man skriver
inn en formbeskrivelse og trykker p\aa{} ``Generer'' og f\aa{}r en liste
genererte former. Formatet p\aa{} analysebeskrivelsene er fors\o{}kt holdt
s\aa{} enhetlig som mulig, p\aa{} formatet \form{lemma+Klasse[+Info\ldots]} og
med rekkef\o{}lgen av informasjonstaggene s\aa{} intuitiv som mulig. For verb
er formatet \form{lamma+Verb+Tempus+Modus+PersTall+Diatese}, for substantiver
\form{lemma\-+Noun\-+Kasus\-+Tall}, for adjektiver
\form{lemma\-+Adj\-+Grad\-+Kj\o{}nn\-+Kasus\-+Tall}, og for adverb
\form{lemma+Adv+Grad}.

\subsection{Koden}\note{Dette m\aa{} utbedres}
Koden er tilgjengelig fra \link{http://heim.ifi.uio.no/arnskj/TODO}, og
best\aa{}r av f\o{}lgende filer og kataloger:

\note{Finn en bedre m\aa{}te \aa{} presentere dette p\aa{}.}
\begin{itemize}
\item[build/] Korte script som bygger og komponerer de forskjellige FSTene
p\aa{} riktig m\aa{}te.
\item[report/] \LaTeX{}-kildekoden til denne rapporten. % XXX: Fjerne fra den endelige leveransen?
\item[t/] Python-script som tester at koden virker som den skal.
\item[vim/] Script for editoren \prog{vim} for \aa{} f\aa{} syntaksmarkering
for \prog{lexc}-- og \prog{twolc}-kode.
\item[web/] Pythonkoden for webgrensesnittet.

\item[Makefile] Regler for \prog{make} for \aa{} bygge FSTene.
\item[TODO] Liste over ting som m\aa{} gj\o{}res. % XXX: Fjerne fra den endelige leveransen?
\item[README] Instruksjoner om bruk og installasjon av applikasjonen.
\item[nouns-lexc.txt] Leksikonspesifikasjon for substantiver.
\item[nouns-twolc.txt] Fonetiske regler for substantiver.
\item[verbs-lexc.txt] Leksikonspesifikasjon for verb.
\item[verbs-twolc.txt] Fonetiske regler for verb.
\end{itemize}

\subsection{Nominalsystemet}\note{Skrive om, og beskrive den historiske
utviklingen i koden i stedet? Snakke om leksikon og slikt f\o{}rst, og s\aa{}
f\o{}ye til at det viste seg at fonologi ble nyttig?}
\label{deklinasjon}
Nominalmorfologien er den delen av systemet som ble skrevet f\o{}rst, og
ogs\aa{} den enkleste. Den latinske nominalmorfologien er forholds enkel, og i
motsetning til for eksempel sanskrit er det ingen vanskelige fenomener som
lydendringer innad i b\o{}yningsr\o{}ttene. De f\aa{} tilfellene av
lydendringer i m\o{}tet mellom rot og endelse er enkle \aa{} hanskes med.
Dette gir en oppbygning der hver rot er bundet mot en b\o{}yningsklasse, og
hver klasse har et sett med endelser for hver enkelt form.




Den latinske nominalmorfologien er forholdsvis enkel. I motsetning til for
eksempel nominalsystemet i sanskrit er det ingen vanskelige fenomener som
lydendringer innad i b\o{}yningsr\o{}ttene, og de f\aa{} tilfellene av
lydendringer i m\o{}tet mellom rot og endelse er enkle \aa{} hanskes med.
Dette gir en oppbygning der hver rot er bundet mot en b\o{}yningsklasse med
sine karakteristiske endelser for de enkelte formene, samt \'en fonetisk regel
for \aa{} h\aa{}ndtere r\o{}tter p\aa{} \w{--er} som mister \w{e} n\aa{}r det
legges til en endelse.

For \aa{} lette implementasjonen har de fleste vekslinger av overflateformen
til roten blitt ansett for \aa{} v\ae{}re leksikalske (unntaket er bortfall av
\w{e} i \w{--er}). Rent lingvistisk hadde det kanskje v\ae{}rt riktigere \aa{}
modellere flere av disse fenomenene som regelrette med fonetiske regler, for
eksempel \w{reg-s} > \w{rex} og \w{flos-is} > \w{floris}. P\aa{} samme
m\aa{}te ender stammefinal vokal opp som endelsesinitial i f\o{}rste og fjerde
deklinasjon, slik at bortfallet av vokalen i dativ/ablativ flertall kan
h\aa{}ndteres i leksikon i stedet for med fonetiske regler. Som nevnt er den
ene fonetiske regelen i nominalsystemet for \aa{} h\aa{}ndtere
synkope\note{Synkope er riktig, no?} i \w{--er}-endelsen. Den fungerer ganske
enkelt slik at de r\o{}ttene som mister \w{e} med endelse har denne markert
som s\aa{}dan i leksikon og den fonetiske regelen fjerner den hvis det kommer
en endelse etter; opprinnelig var denne regelen mer generell og synkoperte
alle forekomster av \w{--er} foran morfemgrense (unntatt i r\o{}ttene \w{puer},
\w{gener}, \w{socer}, \w{liber}, \w{vesper} og \w{signifer}), men det viser
seg at det finnes r\o{}tter p\aa{} \w{--er} som \emph{ikke} har synkope, for
eksempel \w{numerus}, og at synkopen er leksikalisert (se for\o{}vrig
\ref{diakroni} for mer diskusjon om dette).

Adjektivb\o{}yningen h\aa{}ndteres p\aa{} akkurat samme m\aa{}te som
substantivene, inkludert \w{e}-synkope. Derimot er avledningen av adverb noe
utradisjonelt implentert. Adverbavledning er implementert slik at de
forskjellige adverbformene er avledet fra adjektivets b\o{}yningsstamme i den
tilsvarende b\o{}yningsgraden. Dessverre inneb\ae{}rer dette at den genererte
analysen blir \form{lemma+Adj+Pos+Adv} eller tilsvarende, noe som helt klart
ikke er optimalt. Jeg har derfor lagt til en omskrivningsregel p\aa{} toppen
av substantivleksikonet som skriver om analyser p\aa{} denne formen til den
korrekte formen: \form{lemma+Adv+Pos}.

\subsection{Verbalsystemet}
\label{konjugasjon}
Verbalmorfologien er den mest interessante og kompliserte delen av systemet;
den er delt inn i to deler: en leksikondel, som inneholder mesteparten av
koden, og et sett fonetiske omskrivningsregler. Reglene i verbleksikonet tar
leksikonformer og skriver dem om til r\o{}tter etterfulgt av en streng
morfemer, for eksempel er resultatet for \w{amo} presens konjunktiv 2.~person
entall passiv \w{ama-e-ris}. Denne mellomformen behandles s\aa{} av de
fonetiske reglene som setter inn korrekte temavokaler og h\aa{}ndterer
bortfall av lyder; for eksempel omskrives \w{ama-o} til \w{amo} og \w{reg-ris}
til \w{regeris}. Tabellene \ref{endelser} og \ref{tempus} gir en oversikt over
de viktigste person-- og tempusendelsene, henholdsvis, som brukes i systemet.

% TODO: Prov aa flette disse tabellene bedre inn i teksten, saann at det er et
% avsnitt eller to mellom dem.
\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|}
    \hline
       & \multicolumn{2}{c|}{Presens} & \multirow{2}{*}{Perfektum} \\ \cline{2-3}
       & Aktiv & Passiv & \\
    \hline
1.~sg. & \w{--m}   & \w{--r}    & \w{--i}     \\
2.~sg. & \w{--s}   & \w{--ris}  & \w{--isti}  \\
3.~sg. & \w{--t}   & \w{--tur}  & \w{--it}    \\
1.~pl. & \w{--mus} & \w{--mur}  & \w{--imus}  \\
1.~pl. & \w{--tis} & \w{--mini} & \w{--istis} \\
1.~pl. & \w{--nt}  & \w{--ntur} & \w{--erunt} \\
    \hline
\end{tabular}
\caption{Personendelsene}
\label{endelser}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|}
    \hline
                  & Indikativ   & Konjunktiv \\
    \hline
Presens           & $\emptyset$ & \w{--e} (1), \w{--a} (2, 3, 4) \\
Imperfektum       & \w{--ba} & \w{--re} \\
Futurum           & \w{--b} (1, 2), \w{--a} (3, 4) & --- \\
    \hline
Perfektum         & $\emptyset$ & \w{--eri} \\
Pluskvamperfektum & \w{--era} & \w{--isse} \\
Futurum exactum   & \w{--eri} & ---        \\
    \hline
\end{tabular}
\caption{Tempussuffiksene}
\label{tempus}
\end{center}
\end{table}

\note{Frem hit er jeg ganske forn\o{}yd. Resten av avsnittet er skit.}

\note{Faa med at 3B verb noteres med -I i leksikon for aa merke dem som
spesielle.}

\note{De fonetiske reglene er oppdatert siden dette ble skrevet. Sjekk mot
verbs-twolc.txt!}
\paragraph{\code{a:0 <=> \_ \%-: [ o | e ]}} Denne regelen h\aa{}ndterer to
tilfeller hvor stammefinal \w{--a} faller bort: foran \w{--o} i 1.~person
entall presens indikativ og foran suffikset for presens konjunktiv.

\paragraph{\code{\%-:i <=> Cons \_ [ s | t | m ]}} Temavokal i
konsonantstammer er \w{i} foran \w{s}, \w{t} og \w{m}.

\paragraph{\code{\%-:e <=> Cons \_ r}} Temavokal i konsonantstammer er
\w{e} foran \w{r}.

\paragraph{\code{\%-:u <=> Cons \_ n}} Temavokal i konsonantstammer er
\w{u} foran \w{n}.

\paragraph{\code{I:e <=> \_ \%-: r}} Som foreg\aa{}ende regel, men for
stammer p\aa{} kort \w{i}.

\paragraph{\code{I:0 <=> \_ \%-: i .\#.}} Stammefinal kort \w{i} faller bort
foran endelsen \w{--i} (presens infinitiv passiv).

Disse reglene beskriver mer eller mindre generelle regler. De resterende
reglene h\aa{}ndterer den valgfrie \w{v}-synkopen i perfektumssystemet.

\paragraph{\code{v:0 => \ldots}} \w{v} mellom vokal og morfemgrense kan i
enkelte tilfeller falle bort (se \S 41.3 i \citeN{eitrem} og \citeN{ernout},
s.~209-212).

\paragraph{\code{v:0 /<= a \_ \%-: ? r e .\#.}} Bortfall av \w{v} m\aa{}
ikke skje n\aa{}r resultatet vil kunne forveksles med en infinitiv.

\paragraph{\code{e:0 <=> a v:0 \%-: \_}} \w{e} etter bortfalt \w{v} foran
\w{a} faller ogs\aa{} bort.

\paragraph{\code{i:0 <=> a v:0 \%-: \_ ; i v:0 \%-: \_ s}} \w{i} etter
bortfalt \w{v} foran \w{a}, eller foran \w{i} og etter bortfalt \w{v} foran
\w{i}, faller ogs\aa{} bort.

\subsection{Verifisering}
For \aa{} kontrollere at endringer i en del av koden ikke \o{}delegger andre
deler av programmet har jeg skrevet en del tester. Testene er implementert som
Python-programmer som genererer output etter protokollen ``Test Anything
Protocol'' (TAP). Programmet \prog{prove} kj\o{}rer s\aa{} alle
testprogrammene, tolker resultatene og skriver ut statistikker. Testene er
skrevet slik at for hvert par av leksikonform og korrekte former blir de
mulige overflateformene i f\o{}lge reglene generert, og programmet sjekker at:
1) reglene genererer samme antall former som er spesifisert i testprogrammet
og 2) alle formene i testprogrammet blir generert. Totalt blir det utf\o{}rt
5638 tester, for 2892 overflateformer \note{Disse tallene m\aa{} oppdateres!}
(inklusive tilfeller der forskjellige leksikonformer har samme overflateform).
Testene er i stor grad generert ved hjelp av klipp-og-lim og erstatninger ved
hjelp av regul\ae{}re uttrykk.

\section{Synkroni vs.~diakroni}
\label{diakroni}
En morfologisk modell er synkron av natur, men det kan kan ogs\aa{} v\ae{}re
interessant \aa{} se hvordan den synkrone modellen passer med den diakrone
utviklingen av det morfologiske systemet.\note{Ting som m\aa{} med:
\begin{itemize}
\item \w{--er}-synkope. Leksikalisert. Hvorfor?
\end{itemize}
}

\section{Konklusjon}\note{Bedre tittel!}
\note{Ta med ideen om \aa{} simulere historiske regler med
toniv\aa{}formalismen? Det er en riktig festlig ide, og er ikke helt p\aa{}
jordet irrelevant heller, gitt den siste delen med sammenligning av synkroni
og diakroni\ldots}

\clearpage
\bibliographystyle{norchicago}
\bibliography{report}{}

\tableofcontents
\listoftables

\end{document}
